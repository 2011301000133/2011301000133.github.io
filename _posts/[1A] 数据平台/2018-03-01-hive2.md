---
layout: post
title: 【Hive SQL】速查.
categories:
tags: 1A_数据平台
keywords:
description:
order: 162
---

## 建表
### 1. 建一个普通表
```sql
DROP TABLE IF EXISTS app.app_example;
CREATE TABLE app.app_example(
id int comment 'id对应的解释',
col1 int comment '解释1',
col2 int comment '解释2'
)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n';
```
### 2. 建一个分区表
```sql
DROP TABLE IF EXISTS app.app_example;
CREATE TABLE app.app_example(
id int comment 'id对应的解释',
col1 int comment '解释1',
col2 int comment '解释2'
)
partitioned by (dt string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n'
TBLPROPERTIES ('author'='myname');
```
## 插入数据
### 1. 从本地数据插入
```sql
load data local inpath 'file_path' into table tbname;
load data local inpath 'file_path' overwrite into table tbname; -- overwrite抹除原数据

LOAD DATA LOCAL INPATH  'file_path' INTO TABLE tbname PARTITION (country='US', state='CA') -- 插入分区表，增量添加，不是覆盖
LOAD DATA LOCAL INPATH  'file_path' OVERWIRTE INTO TABLE tbname PARTITION (country='US', state='CA') -- 插入分区表，带overwirte表示覆盖
```

### 2. 从查询插入数据
```sql
create  table tb2 as select * from tb1; -- 新建一个表，并以overwrite的方式写入数据
insert into table tb2 select * from tb1; -- 新增插入数据


-- 静态方式插入分区表：
insert overwrite table tmp.tmp_test
partition (country='US',state='OR')
select names from tbname1;

-- 动态方式插入到分区表：
set hive.exec.dynamic.partition.mode=nonstrict;
INSERT OVERWRITE TABLE app.app_example PARTITION(dt)
SELECT col1,col2,sysdate(-1) as dt
FROM
app.example_1
-- 动态方式必须把分区key放在最后，优点是可以同时向多个分区插入数据

-- overwrite表示覆盖插入，去掉overwrite表示增量添加
```

例子：
```sql
DROP TABLE IF EXISTS app.app_example;
CREATE TABLE app.app_example
AS
SELECT * FROM app.example_1;
```

## 修改
```sql
alter table tablename1
CHANGE COLUMN
rpt_tag rpt_tag int comment '1新客，2新转老，3新注册，5老客';
```


## 优化

1. 尽早过滤数据
3. 解决数据倾斜问题


### join
1. join前使用子表过滤掉不需要的数据（新版本Hive已经优化过，无需再这样写）  
1. 多表join时，每个on语句使用同样的连接键（可以减少job数）  
1. join时，把小表放前面，大表放后面，hive会自动缓存其它表  


### 其它
Hive可以从一个数据源产生多个数据聚合，无需每次聚合都重新扫描一次  
```sql
insert overwrite table sales
select * from history where action='purchased';
insert overwrite table credits
select * from history where action='returned';
```
用下面的查询只需扫描一次history表
```sql
from history
insert overwrite sales select * where action='purchased'
insert overwrite credits select * where action='returned';
```


## 用法
看看重复数据的样子

```sql
select id,count(id)
from tablename
group by
id having count(id)>1
```
## 抽样查询
```sql
select * from tmp.tmp_example tablesample(bucket 3 out of 30 on rand()) s;


-- 以某一列为分桶标准,每次运行结果都一样,实际上等价于 where id%10=0
select * from tmp.tmp_example tablesample(bucket 1 out of 10 on id) s;

-- 前20%行
select * from tmp.tmp_example tablesample(20 percent) s;
```




http://blog.csdn.net/mulangren1988/article/details/77509195
