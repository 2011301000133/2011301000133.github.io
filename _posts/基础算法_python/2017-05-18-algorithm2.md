---
layout: post
title: 算法2：Graph&Tree.
categories:
tags: 传统算法
keywords:
description:
---



## graph

>如果我们的工作可以诠释成graph，那么我们至少接近解决方案了。如果能诠释成tree，那么已经拥有一个解决方案了
>例如，XML文档或目录结构都是tree

一些特点

- graph：$G=(V,E)$，其中V是节点，E是边。如果E是有方向的，叫做有向图
- 节点的度数：节点v所在边的个数，
- 节点的邻居：相同边连接的节点
- 加权图，每条边有某种权值
- forest中没有cycle，是由一个或多个tree构成的

### 图表示1
```py
a, b, c, d, e, f, g, h = range(8)
N = [
    {b, c, d, e, f},  # a
    {c, e},           # b
    {d},              # c
    {e},              # d
    {f},              # e
    {c, g, h},        # f
    {f, h},           # g
    {f, g},           # h
]
```
set与dict都是用hash方法实现的，因此访问时间是$\Theta(1)$,最坏时间是$\Theta(n)$  

用法：  
```py
b in N[a] # Neighborhood membership
len(N[f])#Degree
```



```py
a, b, c, d, e, f, g, h = range(8)
N = [
    [b, c, d, e, f],  # a
    [c, e],           # b
    [d],              # c
    [e],              # d
    [f],              # e
    [c, g, h],        # f
    [f, h],           # g
    [f, g],           # h
]
```
### 图表示2:加权图
```py
a,b,c,d,e,f,g,h=range(8)
N=[
    {b:2,c:1,d:3,e:9,f:4}, #a
    {c:4,e:3},       #b
    {d:8},       #c
    {e:8},           #d
    {f:7},      #e
    {c:2,g:2,h:2},  #f
    {f:1,h:6},    #g
    {f:9,g:8},   #h
]
```
一些用法：
```py
b in N[a] # Neighborhood membership
len(N(f)) # Degree
N[a][b]# Edge weight for (a,b)
```

### 表示3：邻接矩阵

```py
a, b, c, d, e, f, g, h = range(8)
N=[[0, 1, 1, 1, 1, 0, 1, 1],
       [1, 0, 1, 0, 1, 0, 1, 1],
       [0, 0, 0, 1, 1, 1, 1, 0],
       [1, 0, 0, 0, 1, 0, 0, 0],
       [0, 1, 1, 0, 0, 0, 1, 1],
       [1, 0, 1, 0, 0, 0, 0, 0],
       [1, 1, 0, 0, 0, 1, 0, 1],
       [1, 0, 1, 0, 1, 1, 1, 0]]
```

```py
N[a][b] # Neighborhood membership
sum(N[f]) # Degree
```

### 表示4：加权图
```py
inf = float('inf')
a, b, c, d, e, f, g, h = range(8)
N = [[0, 111, 88, 96, 116, 102, 71, 176],
     [inf, 0, 32, 19, inf, inf, 64, 210],
     [110, 35, 0, 144, 108, 106, 35, 126],
     [inf, inf, inf, 0, 15, 38, 119, inf],
     [inf, inf, 58, 105, 0, inf, 19, inf],
     [148, inf, 143, inf, 44, 0, 154, 163],
     [49, 174, 68, 48, 258, 76, 0, inf],
     [99, 143, 85, 159, 2, 44, 74, 0]]
```

```py
N[a][b]#<inf # Neighborhood membership
sum([1 for i in N[e] if i<inf])-1# Degree
```
取Degree的时间复杂度是$\Theta(n)$  


## tree
