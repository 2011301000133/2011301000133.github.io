---
layout: post
title: 算法1：理论篇.
categories:
tags: 传统算法
keywords:
description:
---

## 理论篇

一些定义：
### 定义1  
$O(g)$代表一组函数，  
$f\in O(g) \Leftrightarrow$  
$ \exists n_0 ,c $使得$\forall n \geq n_0 , f(n) \leq cg(n)$
### 定义2
$\Omega (g)$的定义恰恰相反
$ \exists n_0 ,c $使得$\forall n \geq n_0 , f(n) \geq cg(n)$
### 定义3
$\Theta(g)=O(g) \cap \Omega(g)$

## 树和图
tree&graph
>如果我们的工作可以诠释成graph，那么我们至少接近解决方案了。如果能诠释成tree，那么已经拥有一个解决方案了
>例如，XML文档或目录结构都是tree

一些特点

- graph：$G=(V,E)$，其中V是节点，E是边。如果E是有方向的，叫做有向图
- 节点的度数：节点v所在边的个数，
- 节点的邻居：相同边连接的节点
- 加权图，每条边有某种权值
- forest中没有cycle，是由一个或多个tree构成的

### 图表示1
```
a, b, c, d, e, f, g, h = range(8)
N = [
    {b, c, d, e, f},  # a
    {c, e},           # b
    {d},              # c
    {e},              # d
    {f},              # e
    {c, g, h},        # f
    {f, h},           # g
    {f, g},           # h
]
```
set与dict都是用hash方法实现的，因此访问时间是$\Theta(1)$,最坏时间是$\Theta(n)$  

```
b in N[a]
len(N[f])
```

与set/dict相比，list擅长内存使用和迭代，不擅长成员检测$(\Theta (lg k))$  
```
a, b, c, d, e, f, g, h = range(8)
N = [
    [b, c, d, e, f],  # a
    [c, e],           # b
    [d],              # c
    [e],              # d
    [f],              # e
    [c, g, h],        # f
    [f, h],           # g
    [f, g],           # h
]
```
