---
layout: post
title: 【Python】【heapq】堆结构.
categories:
tags: 5数据机构与算法
keywords:
description:
order: 510
---

heapq 模块提供堆算法，[官方文档](https://docs.python.org/3.5/library/heapq.html?highlight=heapq)写的很好，摘抄下来(对格式和段落进行了整理)：  

## NAME:  
>This module provides an implementation of the heap queue algorithm, also known as the priority queue algorithm.  

## DESCRIPTION
>Heaps are binary trees for which every parent node has a value less than or equal to any of its children. This implementation uses arrays for which heap[k] <= heap[2*k+1] and heap[k] <= heap[2*k+2] for all k, counting elements from zero. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that its smallest element is always the root, heap[0].

## functions  

### heapq.heappush(heap, item)
Push the value item onto the heap, maintaining the heap invariant.

### heapq.heappop(heap)
Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0].

### heapq.heappushpop(heap, item)
Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop().

### heapq.heapify(x)
Transform list x into a heap, in-place, in linear time.

### heapq.heapreplace(heap, item)
Pop and return the smallest item from the heap, and also push the new item. The heap size doesn’t change. If the heap is empty, IndexError is raised.

This one step operation is more efficient than a heappop() followed by heappush() and can be more appropriate when using a fixed-size heap. The pop/push combination always returns an element from the heap and replaces it with item.

还有一些function，这里略去不写  

## 应用

仔细看完官方文档，应该对heapq的作用有了解了，下面是一些应用

### show_tree
（这个函数来自网络）  
这个是自编函数，功能是打印heap  
可以输入list，也可以输入heap  
```py
import math
from io import StringIO


def show_tree(tree, total_width=36, fill=' '):
    output = StringIO()
    last_row = -1
    for i, n in enumerate(tree):
        if i:
            row = int(math.floor(math.log(i + 1, 2)))
        else:
            row = 0
        if row != last_row:
            output.write('\n')
        columns = 2 ** row
        col_width = int(math.floor((total_width * 1.0) / columns))
        output.write(str(n).center(col_width, fill))
        last_row = row
    print(output.getvalue())
    print('-' * total_width)
    print
    return
```

#### 应用示例1:show_tree
（输入可以是list，也可以是heap）  
```py
data = range(1, 8)
print('data: ', data)
show_tree(data)
```

output
```
data:  range(1, 8)

                 1                  
        2                 3         
    4        5        6        7    
------------------------------------
```

#### 应用示例2：heapify

heapify可以在线性时间内进行排序  
需要注意，直接改输入的list，而不是return一个list  

```py
import random
import heapq
heap = random.sample(range(1, 8), 7)
heapq.heapify(heap)
show_tree(heap)
```

output  
```

                 7                  
        3                 5         
    1        2        4        6    
------------------------------------

                 1                  
        2                 4         
    3        7        5        6    
------------------------------------
```

#### 应用示例3：heappush

下面展示多次heappush的过程：  

```py
import math
from io import StringIO


def show_tree(tree, total_width=36, fill=' '):
    output = StringIO()
    last_row = -1
    for i, n in enumerate(tree):
        if i:
            row = int(math.floor(math.log(i + 1, 2)))
        else:
            row = 0
        if row != last_row:
            output.write('\n')
        columns = 2 ** row
        col_width = int(math.floor((total_width * 1.0) / columns))
        output.write(str(n).center(col_width, fill))
        last_row = row
    print(output.getvalue())
    print('-' * total_width)
    print
    return

import heapq
import random

heap = []
data = random.sample(range(1, 8), 7)
print('data:', data)
for i in data:
    heapq.heappush(heap, i)
    show_tree(heap)
```

output：  

```
data: [1, 4, 7, 6, 2, 5, 3]

                 1                  
------------------------------------

                 1                  
        4         
------------------------------------

                 1                  
        4                 7         
------------------------------------

                 1                  
        4                 7         
    6    
------------------------------------

                 1                  
        2                 7         
    6        4    
------------------------------------

                 1                  
        2                 5         
    6        4        7    
------------------------------------

                 1                  
        2                 3         
    6        4        7        5    
------------------------------------
```

#### 应用示例4：heappop

```py
import math
from io import StringIO


def show_tree(tree, total_width=36, fill=' '):
    output = StringIO()
    last_row = -1
    for i, n in enumerate(tree):
        if i:
            row = int(math.floor(math.log(i + 1, 2)))
        else:
            row = 0
        if row != last_row:
            output.write('\n')
        columns = 2 ** row
        col_width = int(math.floor((total_width * 1.0) / columns))
        output.write(str(n).center(col_width, fill))
        last_row = row
    print(output.getvalue())
    print('-' * total_width)
    print
    return

import heapq
import random

data = random.sample(range(1, 8), 7)
print ('data: ', data)
heapq.heapify(data)
show_tree(data)

heap = []
while data:
    i = heapq.heappop(data)
    print('pop %3d:' % i)
    show_tree(data)
    heap.append(i)
print('heap: ', heap)
```
