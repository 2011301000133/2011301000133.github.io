---
layout: post
title: HQL应用举例.
categories:
tags: 1数据准备
keywords:
description:
order: 142
---

## 建表
### 1. 建一个普通表
```
DROP TABLE IF EXISTS app.app_example;
CREATE TABLE app.app_example(
id int comment 'id对应的解释',
col1 int comment '解释1',
col2 int comment '解释2'
)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n';
```
### 2. 建一个分区表
```
DROP TABLE IF EXISTS app.app_example;
CREATE TABLE app.app_example(
id int comment 'id对应的解释',
col1 int comment '解释1',
col2 int comment '解释2'
)
partitioned by (dt string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n';
```
## 插入数据
### 1. 从本地数据插入
```
load data local inpath 'file_path' into table tbname;
load data local inpath 'file_path' overwrite into table tbname; -- overwrite
```

### 2. 从查询插入数据
```
create  table tb2 as select * from tb1; -- overwrite
insert into table tb2 select * from tb1; -- 新增插入数据
```

例子：
```
DROP TABLE IF EXISTS app.app_example;
CREATE TABLE app.app_example
AS
SELECT * FROM app.example_1;
```

### 3. 插入数据到已建立的分区表中
```
set hive.exec.dynamic.partition.mode=nonstrict;
INSERT OVERWRITE TABLE app.app_example PARTITION(dt)
SELECT col1,col2,sysdate(-1) as dt
FROM
app.example_1
```

## 查询案例

### 找出重复的记录
```
SELECT id,COUNT(id)
FROM table1
WHERE dt = '2018-02-16'
GROUP BY id HAVING COUNT(id) > 2;
```

*where group by 顺序不能反了，不然报错*  

## 分析函数

一般语法是：
```
function() OVER([partition_clause]  order_by_clause)
```

### over部分
```
over（order by col1）：对查询的整个数据范围内的数据，按照字段col1排序
over（partition by col2）：按照字段col2分组，统计每个组内的数据
over（partition by col2 order by col1）：按照字段col2分组，每个分组内按照字段col1排序
over（order by col3 range between 2 preceding and 2 following）：窗口范围为当前行数据幅度减2加2后的范围内的 ---- 按列值控制窗口大小
over（order by col3 rows between 2 preceding and 2 following）：窗口范围为当前行前后各移动2行 ---- 按行数控制窗口大小
```

关键字解释：

- ROWS：指定行
- RANGE：指定范围
- PRECEDING：往前
- FOLLOWING：往后
- CURRENT ROW：当前行
- UNBOUNDED：起点
- UNBOUNDED PRECEDING：表示从前面的起点开始
- UNBOUNDED FOLLOWING：表示到后面的终点结束


### function部分
#### 1. 排名函数

**row_number()**: 会对所有数值输出不同的序号，序号唯一连续；  
**rank()**: 相同的值排名相同，并且排名数字靠前，（例如，排名可能是这样的：1,1,3,3,5,6,7）  
<!-- 公司hive里面不太对   -->

**DENSE_RANK**：排名序号连续(例如：1,1,2,2,3,3,4)
**ntile(n)**： 全部数据n等分，序号就是等分数(1到n),如果不能平均分配，那么序号靠后的组的数量不多于序号靠前的(例如，ntile(3)分5条记录，就是2,2,1)  


**PERCENT_RANK()**：计算当前行的百分比排名 ——（当前行排名 - 1）/（窗口分区中的行数 - 1）  
**CUME_DIST**：计算当前行的相对排名——（前面的行数[+相等值行数]）/（分区中的总行数）


应用案例1：
https://jingyan.baidu.com/article/9989c74604a644f648ecfef3.html

应用案例2：（选出每组最大的记录）  
```
select * from app.app_temp_test where row_number(id)<=1;
```

#### 2. 层次查询函数
