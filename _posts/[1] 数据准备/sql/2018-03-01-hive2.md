---
layout: post
title: HQL速查.
categories:
tags: 1数据准备
keywords:
description:
order: 142
---

## 建表
### 1. 建一个普通表
```
DROP TABLE IF EXISTS app.app_example;
CREATE TABLE app.app_example(
id int comment 'id对应的解释',
col1 int comment '解释1',
col2 int comment '解释2'
)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n';
```
### 2. 建一个分区表
```
DROP TABLE IF EXISTS app.app_example;
CREATE TABLE app.app_example(
id int comment 'id对应的解释',
col1 int comment '解释1',
col2 int comment '解释2'
)
partitioned by (dt string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n';
```
## 插入数据
### 1. 从本地数据插入
```
load data local inpath 'file_path' into table tbname;
load data local inpath 'file_path' overwrite into table tbname; -- overwrite抹除原数据

LOAD DATA LOCAL INPATH  'file_path' INTO TABLE tbname PARTITION (country='US', state='CA') -- 插入分区表，增量添加，不是覆盖
LOAD DATA LOCAL INPATH  'file_path' OVERWIRTE INTO TABLE tbname PARTITION (country='US', state='CA') -- 插入分区表，带overwirte表示覆盖
```

### 2. 从查询插入数据
```
create  table tb2 as select * from tb1; -- 新建一个表，并以overwrite的方式写入数据
insert into table tb2 select * from tb1; -- 新增插入数据


-- 静态方式插入分区表：
insert overwrite table tmp.tmp_test
partition (country='US',state='OR')
select names from tbname1;

-- 动态方式插入到分区表：
set hive.exec.dynamic.partition.mode=nonstrict;
INSERT OVERWRITE TABLE app.app_example PARTITION(dt)
SELECT col1,col2,sysdate(-1) as dt
FROM
app.example_1
-- 动态方式必须把分区key放在最后，优点是可以同时向多个分区插入数据

-- overwrite表示覆盖插入，去掉overwrite表示增量添加
```

例子：
```
DROP TABLE IF EXISTS app.app_example;
CREATE TABLE app.app_example
AS
SELECT * FROM app.example_1;
```

## 修改
```
alter table tablename1
CHANGE COLUMN
rpt_tag rpt_tag int comment '1新客，2新转老，3新注册，5老客';
```


## 优化
1. 多表join时，每个on语句使用同样的连接键
1. join时，把小表放前面，大表放后面，hive会自动缓存其它表


## 用法
看看重复数据的样子

```sql
select id,count(id)
from tablename
group by
id having count(id)>1
```
## 抽样查询
```sql
select * from tablename1 tablesample(bucket 3 out of 10 on rand()) s;

-- 去掉rand()每次运行结果都一样
select * from tablename1 tablesample(bucket 3 out of 10) s;

-- 以某一列为分桶标准
select * from tablename1 tablesample(bucket 3 out of 10 on col1) s;

-- 按百分比抽
select * from tablename1 tablesample(0.1 percent)s;
```

http://blog.csdn.net/mulangren1988/article/details/77509195
