---
layout: post
title: 贝叶斯参数估计.
categories: 趣文
tags:
keywords:
description:
---

### 问题提出
假设一次实验结果只有两种，那么有理由相信每个事件发生的概率是一个均匀分布  
（这个问题中，事件发生的概率本身是一个有待估计的随机变量）  


先验分布是这样的：  
$$\left\{ \begin{array}{l}
P(x=0)=\theta\\
P(x=1)=1-\theta\\
\theta\sim U(0,1)
\end{array}\right.$$  
(有理由相信，未得到实验数据之前，认为先验的参数是均匀分布)  


### 问题解决
根据贝叶斯公式  
$P(\theta\mid X)$  
$=\dfrac{P(X\mid\theta)P(\theta)}{\int_{-\infty}^{+\infty} P(X\theta \mid)P(\theta)d\theta}$  


假设经过两次实验，结果是(1,1)，那么  
$P(X\mid\theta)=(1-\theta)^2$  
$P(\theta)=1,\forall \theta\in(0,1)$  
结果是$P(\theta\mid X)=3(1-\theta)^2$  


### 数值计算

```py
def func_prob_theta(theta):
    '''
    p(\theta) 先验分布
    '''
    if 0 < theta < 1:
        return 1
    else:
        return 0


def func_prob_X_given_theta(X, theta):
    '''
    $P(X\mid\theta)$
    :param X: list，每次实验的结果，例如[1,0,0,1,1]
    :param theta:
    :return:
    例如，X=[1,0,0,1,0,0]
    func_prob_X_given_theta(X,0.5)，代表均匀0-1分布下，X这个实验结果出现的概率
    '''
    prob_X_given_theta = func_prob_theta(theta)
    for x in X:
        prob_X_given_theta *= theta ** (1 - x) * (1 - theta) ** x
    return prob_X_given_theta


# 假如某次实验结果是这样的：
X = [1, 1, 0, 0, 1, 1]

# 先计算分母，这是一个积分：
from scipy import integrate

func = lambda theta: func_prob_X_given_theta(X, theta)
S, _ = integrate.quad(func, 0, 1)

# 计算并画出Theta的概率密度分布图
import numpy as np

list_p_theta = []
Theta = np.arange(0, 1, 0.01)
for theta in Theta:
    list_p_theta.append(func(theta) / S)

import matplotlib.pyplot as plt

plt.plot(Theta, list_p_theta)
plt.title(X)
plt.show()
```

上结果：(标题是此次实验结果)  
![1](https://www.guofei.site/pictures_for_blog/beyes/1.png)  
![2](https://www.guofei.site/pictures_for_blog//beyes/2.png)  
这是20个1和10个0的实验结果  
![3](https://www.guofei.site/pictures_for_blog//beyes/3.png)  
这是200个1和100个0的实验结果  
![4](https://www.guofei.site/pictures_for_blog//beyes/4.png)  


## 火车头问题
选自弗雷德里克·莫斯泰勒《五十个概率难题的解法》  
铁路上火车头以1到N命名，你看到3个火车头，标号分别为30,60,90. 请估计铁路上有多少火车头  

**1. 假设先验为均匀分布**  
$\theta \sim U(90,N)$  
X:看到标号 30,60,90  


所以，  
$P(X\mid \theta)=\dfrac{1}{\theta}$  
$$
