---
layout: post
title: 算法2：Graph&Tree.
categories: 算法
tags: 经典算法
keywords:
description:
---



## Graph

>如果我们的工作可以诠释成graph，那么我们至少接近解决方案了。如果能诠释成tree，那么已经拥有一个解决方案了
>例如，XML文档或目录结构都是tree  
例如，机器学习中的决策树也是tree，而神经网络一般是graph


### Graph

- graph：$G=(V,E)$，其中V是节点，E是边。如果E是有方向的，叫做有向图
- 节点的度数：节点v所在边的个数，
- 节点的邻居：相同边连接的节点
- 加权图：每条边有某种权值

### 子图
$H=(W,F)$是$G=(V,E)$的子图，如果$W \subseteq V,F \subseteq E$

### 连通图
任意两点之间都存在路径

### 路径，环路
- `路径`是子图，边是连续连接节点构成的  
- 路径终点上添加一条指向起点的边，构成一条`环路`(cycle)  

### 森林Forest
- 不包含环的图叫做`无环图`
- 无向的无环图叫做`森林`
- 连通的森林叫做`树`
- Forest可以由一个或多个tree构成

### 生成树

连通无向图G的生成树T是这么定义的：  
$G=(V,E), T=(V,E_1), E_1 \subseteq E$  
(当然，如果G不是连通图，那么也不存在生成树)  

#### 最小生成树

T是G的生成树，如果G是加权图，$w(T)=\sum\limits_{e\in E_1} w(e)$  
那么，使得$w(T)$最小的T，叫做最小生成树  

### 一个定理

假设T是一个有n个节点的无向图，那么以下6个命题等价
- T是一个树
- T是无环图，且有n-1个边
- T是连通图，且有n-1个边
- 任意两个节点之间有且只有一条路径
- T是无环图，且任意添加一条边都会产生环路
- T是连通图，但任意删除一条边都会把T变成两个连通分量  


## 代码表示

### list表示法

#### list-set表示
```py
a, b, c, d, e, f, g, h = range(8)
N = [
    {b, c, d, e, f},  # a
    {c, e},           # b
    {d},              # c
    {e},              # d
    {f},              # e
    {c, g, h},        # f
    {f, h},           # g
    {f, g},           # h
]
```
set与dict都是用hash方法实现的，因此访问时间是$\Theta(1)$,最坏时间是$\Theta(n)$  

用法：  
```py
b in N[a] # Neighborhood membership
len(N[f])#Degree
```


#### list表示
```py
a, b, c, d, e, f, g, h = range(8)
N = [
    [b, c, d, e, f],  # a
    [c, e],           # b
    [d],              # c
    [e],              # d
    [f],              # e
    [c, g, h],        # f
    [f, h],           # g
    [f, g],           # h
]
```

#### list-dict表示：用于加权图
```py
a,b,c,d,e,f,g,h=range(8)
N=[
    {b:2,c:1,d:3,e:9,f:4}, #a
    {c:4,e:3},       #b
    {d:8},       #c
    {e:8},           #d
    {f:7},      #e
    {c:2,g:2,h:2},  #f
    {f:1,h:6},    #g
    {f:9,g:8},   #h
]
```
一些用法：
```py
b in N[a] # Neighborhood membership
len(N[f]) # Degree
N[a][b]# Edge weight for (a,b)
```

#### dict-dict表示：加权图

```py
a, b, c, d, e, f, g, h = range(8)
G = {
    a: {b: 2, c: 1, d: 3, e: 9, f: 4},
    b: {c: 4, e: 3},
    c: {d: 8},
    d: {e: 8},
    e: {f: 7},
    f: {c: 2, g: 2, h: 2},
    g: {f: 1, h: 6},
    h: {f: 9, g: 8},
}
```

用法  
```py
[(G[u][v], u, v) for u in G for v in G[u]]
```
### 矩阵表示法
#### 邻接矩阵

```py
a, b, c, d, e, f, g, h = range(8)
N=[[0, 1, 1, 1, 1, 0, 1, 1],
       [1, 0, 1, 0, 1, 0, 1, 1],
       [0, 0, 0, 1, 1, 1, 1, 0],
       [1, 0, 0, 0, 1, 0, 0, 0],
       [0, 1, 1, 0, 0, 0, 1, 1],
       [1, 0, 1, 0, 0, 0, 0, 0],
       [1, 1, 0, 0, 0, 1, 0, 1],
       [1, 0, 1, 0, 1, 1, 1, 0]]
```

```py
N[a][b] # Neighborhood membership
sum(N[f]) # Degree
```

#### 邻接矩阵：加权图
```py
inf = float('inf')
a, b, c, d, e, f, g, h = range(8)
N = [[0, 111, 88, 96, 116, 102, 71, 176],
     [inf, 0, 32, 19, inf, inf, 64, 210],
     [110, 35, 0, 144, 108, 106, 35, 126],
     [inf, inf, inf, 0, 15, 38, 119, inf],
     [inf, inf, 58, 105, 0, inf, 19, inf],
     [148, inf, 143, inf, 44, 0, 154, 163],
     [49, 174, 68, 48, 258, 76, 0, inf],
     [99, 143, 85, 159, 2, 44, 74, 0]]
```

```py
N[a][b]#<inf # Neighborhood membership
sum([1 for i in N[e] if i<inf])-1# Degree
```
取Degree的时间复杂度是$\Theta(n)$  

## Tree


### Tree的相关定义
**根节点**：没有父节点的点  
**节点的度**：某个节点拥有子节点的个数  
**叶节点**：度为0的节点  
**分支节点**：度不为0的节点  
**子节点**  
**父节点**  
**兄弟节点**：共享同一个`父节点`的节点  
**树的度**：所有节点的度的最大值  
**节点的层次**：从根节点到某节点路径上的分支数，根节点的层次是0， 任意节点的层次=父节点的层次+1  
**树的深度**：所有节点的层次的最大值。空树的深度是-1，只有一个根节点的树的深度是0  
**无序树**：兄弟节点是无序的  
**有序树**：兄弟节点是有序的。`二叉树`是一种有序树。  
**森林**：m($m\geq 0$)颗树的集合叫做森林。一棵树的根节点有m颗子树，那么删掉根节点后，就变成包含m颗树的森林


### Tree的一些特点


对树进行删除、插入、搜索操作，最坏情况下复杂度为$\Theta(\lg n)$

### Tree的代码表示

#### 父节点表示法

|点|父节点|
|--|--|
|0|-1|
|1|0|
|2|0|
|3|1|
|...|...|

优点：寻找父节点方便  
缺点：寻找子节点不方便  

#### 子节点表示法

实现难点在于子节点的个数未知

|点|子节点|
|--|--|
|||
|||


对于二叉树：

|点|左子节点|右子节点|
|--|--|--|
||||
|||


#### 父子节点表示法

既有父节点，又有子节点

#### 子兄弟表示法
既有子节点，也有兄弟节点

### 二叉树

二叉树是一种`有序树`，由一个根节点和两个互不相交的子二叉树构成，两个自子二叉树分别叫做`左子树`和`右子树`  

**满二叉树** ：一颗二叉树上，所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层。  

**完全二叉树**：一个有n个节点的二叉树与某个满二叉树的前n个节点结构完全相同，这样的二叉树叫做完全二叉树。*（可以理解为满二叉树去掉后面某些节点）*  

#### 二叉树的性质

规定根节点的层次为0，空树的深度为-1
- 第i层上最多有$2^i$个节点
- 
