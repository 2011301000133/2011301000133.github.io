---
layout: post
title: 【Python】【算法题集3】
categories:
tags: 8_2_有趣的算法
keywords:
description:
order: 821001
---

## 定义
1. 我们讨论二维情况
2. 可以通行的区域，我们叫做“路”
3. 不可通行的区域，我们叫做“墙”

## 方案1：深度优先搜索
特点
- 有一条特别长的主路
- 路线很扭曲

```py
import matplotlib.pyplot as plt
import numpy as np

# step1：生成一个网点图
length, width = 50, 50  # 定义迷宫大小
maze = np.zeros(shape=(length, width))
maze[::2, ::2] = 1

# 每次只能上下左右试探
step_set = np.array([[1, 0],
                     [-1, 0],
                     [0, 1],
                     [0, -1]])


def find_next_step(maze, point, step_set):
    # 用递归实现深度优先搜索
    step_set = np.random.permutation(step_set)
    for next_step in step_set:
        next_point = point + next_step * 2
        x, y = next_point
        if 0 <= x < length and 0 <= y < width:  # 在格子内
            if maze[x, y] == 1:  # 如果还没打通，就打通
                maze[x, y] = 2
                maze[(point + next_step)[0], (point + next_step)[1]] = 2
                maze, _, _ = find_next_step(maze, next_point, step_set)  # 深度优先搜索
    # 全部遍历后，还是找不到，就是这个叶节点没有下一步了，返回即可
    return maze, point, step_set


# 定义起点
point = np.array([0, 0])
find_next_step(maze, point, step_set)

# 至于终点，道路上的每个点都可以作为终点
plt.imshow(maze)
plt.show()
```

## 方案2：广度优先搜索
既然有深度优先搜索，就有广度优先搜索。  
实现方法就是深度优先搜索方案改一改。  
地图特点：
- 不会出现一条特别长的主路的情况

## 改进：分块生成迷宫
前面我们已经有了生成迷宫的方法，自然能想到分块生成迷宫，这种方法可以实现以下两种迷宫
1. 有时候，我们不想让迷宫太复杂，想让某些分支路线限定在某个区域内。
2. 有时候，我们不想让路径填充整个迷宫，想留下一片未开垦地。
