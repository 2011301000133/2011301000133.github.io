
画心和名字
```py
import numpy as np
import matplotlib.pyplot as plt

string = np.array(['郭','飞']*20)
n, = string.shape

t = np.linspace(0, 2 * np.pi, n)
a=1
x=a * (2 * np.sin(t) - np.sin(2 * t))
y=a * (2 * np.cos(t) - np.cos(2 * t))


fig,ax = plt.subplots(1,1)
plt.setp(ax, 'xticks', [])
plt.setp(ax, 'yticks', [])
ax.plot(x, y)
for i, j, k in zip(x, y, string):
    ax.text(i, j, k, fontname='STKaiti', fontsize=20, color='r', transform=ax.transData)  # 数据坐标

plt.show()
```

这个心好像更好看
```py
t = np.linspace(0, 2 * np.pi, n)
x = 16 * (np.sin(t)) ** 3
y = 13 * np.cos(t) - 5 * np.cos(2 * t) - 2 * np.cos(3 * t) - np.cos(4 * t)
```

## 名字比心
```py
import matplotlib.pyplot as plt

# 造一张汉字组成的图
fig = plt.figure(0)
ax = fig.subplots(1, 1)
ax.text(0.1, 0.5, '郭飞 郭飞飞', fontname='STKaiti', fontsize=70, color='k', transform=ax.transAxes)

ax.set_axis_off()
plt.setp(ax, 'xticks', [], 'yticks', [])
plt.savefig('name.jpg')

# %%
import numpy as np
from sklearn import preprocessing

# 载入图像，作为起点
name_data = plt.imread('name.jpg')[:, :, 0]
name_data = np.rot90(name_data, k=-1)  # 因为矩阵和坐标序号不一样，所以需要旋转一下
name_data = (name_data < 100) * 1

# 计算起点
start_point = np.argwhere(name_data) / 1.0  # 返回坐标

# 计算终点
t = np.linspace(0, 2 * np.pi, start_point.shape[0])
t = np.random.permutation(t)  # 打乱顺序，这样点比较散，图像更好看
end_point = np.zeros_like(start_point)
end_point[:, 0] = 16 * (np.sin(t)) ** 3
end_point[:, 1] = 13 * np.cos(t) - 5 * np.cos(2 * t) - 2 * np.cos(3 * t) - np.cos(4 * t)

# 归一化
min_max_scaler = preprocessing.MinMaxScaler()
start_point = min_max_scaler.fit_transform(start_point)
end_point = min_max_scaler.fit_transform(end_point)

fig = plt.figure(1)
ax = fig.subplots(1, 1)
line = ax.plot(start_point[:, 0], start_point[:, 1], '.r')
plt.ion()
for i in np.linspace(-1, 1, 100):
    k=(1-abs(i))**3
    point = start_point + (end_point - start_point) *k
    plt.setp(line, 'xdata', point[:, 0], 'ydata', point[:, 1])
    plt.pause(0.1)
```

## 用傅里叶变化画心
```py
import numpy as np
import matplotlib.pyplot as plt

n = 100
t = np.linspace(0, 2 * np.pi, n)
x1 = 16 * (np.sin(t)) ** 3
y1 = 13 * np.cos(t) - 5 * np.cos(2 * t) - 2 * np.cos(3 * t) - np.cos(4 * t)

X = x1 + 1j * y1
x = np.fft.fft(X)

fig, ax = plt.subplots(1, 1)
ax.plot(X.real, X.imag, '-b')

ax.set_xlim(X.real.min(), X.real.max())
ax.set_ylim(X.imag.min(), X.imag.max())

plt.ion()
point_plt = ax.plot(0, 0, 'ro')
circle_plt_list, radius_plt_list = [], []
for i in range(n):
    radius = x[i]
    center = 0
    circle_point = center + radius * np.exp(1j * np.linspace(0, 2 * np.pi, 10))
    circle_plt = ax.plot(circle_point.real, circle_point.imag, 'g')
    circle_plt_list.append(circle_plt)
    radius_plt = ax.plot([0, 0], [0, 0], color='r', marker='o', linestyle='-')
    radius_plt_list.append(radius_plt)

circle = plt.plot()
p_list = []

for i in range(n):
    print(i)
    right = np.exp(i * 1j * 2 * np.pi * np.arange(n) / n)
    p = np.sum(x * right) / n
    p_list.append(p)
    plt.setp(point_plt, 'xdata', p.real, 'ydata', p.imag)
    center_list = []
    for j in range(n):
        center = np.sum(x[:j] * right[:j]) / n
        radius = x[j]
        circle_point = center + radius * np.exp(1j * np.linspace(0, 2 * np.pi, 30)) / n
        plt.setp(circle_plt_list[j], 'xdata', circle_point.real, 'ydata', circle_point.imag)
        center_list.append(center)
        if j > 0:
            plt.setp(radius_plt_list[j - 1], 'xdata', [center_last.real, center.real], 'ydata',
                     [center_last.imag, center.imag])
        center_last = center
    plt.setp(radius_plt_list[-1], 'xdata', [center_last.real, p.real], 'ydata',
             [center_last.imag, p.imag])
    plt.pause(0.1)
```
