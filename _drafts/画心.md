
画心和名字
```
import numpy as np
import matplotlib.pyplot as plt

string = np.array(['郭','飞']*20)
n, = string.shape

t = np.linspace(0, 2 * np.pi, n)
a=1
x=a * (2 * np.sin(t) - np.sin(2 * t))
y=a * (2 * np.cos(t) - np.cos(2 * t))


fig,ax = plt.subplots(1,1)
plt.setp(ax, 'xticks', [])
plt.setp(ax, 'yticks', [])
ax.plot(x, y)
for i, j, k in zip(x, y, string):
    ax.text(i, j, k, fontname='STKaiti', fontsize=20, color='r', transform=ax.transData)  # 数据坐标

plt.show()
```

这个心好像更好看
```
import numpy as np
import matplotlib.pyplot as plt

string = np.array(['郭', '飞'] * 20)
n, = string.shape

t = np.linspace(0, 2 * np.pi, n)
x = 16 * (np.sin(t)) ** 3
y = 13 * np.cos(t) - 5 * np.cos(2 * t) - 2 * np.cos(3 * t) - np.cos(4 * t)

fig, ax = plt.subplots(1, 1)
plt.setp(ax, 'xticks', [])
plt.setp(ax, 'yticks', [])
ax.plot(x, y)
for i, j, k in zip(x, y, string):
    ax.text(i, j, k, fontname='STKaiti', fontsize=20, color='r', transform=ax.transData)  # 数据坐标

plt.show()
```

## 名字比心
```py
import matplotlib.pyplot as plt

# 造一张汉字组成的图
fig = plt.figure(0)
ax = fig.subplots(1, 1)
ax.text(0.1, 0.5, '郭飞 郭飞飞', fontname='STKaiti', fontsize=70, color='k', transform=ax.transAxes)

ax.set_axis_off()
plt.setp(ax, 'xticks', [], 'yticks', [])
plt.savefig('name.jpg')

# %%
import numpy as np
from sklearn import preprocessing

# 载入图像，作为起点
name_data = plt.imread('name.jpg')[:, :, 0]
name_data = np.rot90(name_data, k=-1)  # 因为矩阵和坐标序号不一样，所以需要旋转一下
name_data = (name_data < 100) * 1

# 计算起点
start_point = np.argwhere(name_data) / 1.0  # 返回坐标

# 计算终点
t = np.linspace(0, 2 * np.pi, start_point.shape[0])
t = np.random.permutation(t)  # 打乱顺序，这样点比较散，图像更好看
end_point = np.zeros_like(start_point)
end_point[:, 0] = 16 * (np.sin(t)) ** 3
end_point[:, 1] = 13 * np.cos(t) - 5 * np.cos(2 * t) - 2 * np.cos(3 * t) - np.cos(4 * t)

# 归一化
min_max_scaler = preprocessing.MinMaxScaler()
start_point = min_max_scaler.fit_transform(start_point)
end_point = min_max_scaler.fit_transform(end_point)

fig = plt.figure(1)
ax = fig.subplots(1, 1)
line = ax.plot(start_point[:, 0], start_point[:, 1], '.r')
plt.ion()
for i in np.linspace(-1, 1, 100):
    k=(1-abs(i))**3
    point = start_point + (end_point - start_point) *k
    plt.setp(line, 'xdata', point[:, 0], 'ydata', point[:, 1])
    plt.pause(0.1)
```
